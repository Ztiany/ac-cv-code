#ifndef README_H
#define README_H

/** =========================================================================
播放器开发：

一、Qt 部分开发：

（1）整体界面搭建：
    主要就是拖控件、各种对齐方式的使用。
    Label 组件使用等宽字体可防止 UI 跳动。

（2）自定义组件：为了封装逻辑：
    VideoWidget：显示（渲染）数据。
    VolumeSlider：优化默认 Slider 点击改变进度的体验【自定义控件后通过提升了改变 xml 中已有的控件】。

二、视频播放开发步骤：

    1. 解封装
    2. 解码（如有必要，还需要适配格式，即重采样）
    3. 播放
    4. 音视频同步：涉及到多线程、互斥锁与条件变量

三、本地播放器功能与 VideoPlayer 设计

    本地播放器功能：
        1. 音视频播放
        2. 暂停播放
        3. 停止播放
        4. 音量调节
        5. 进度调节

    VideoPlayer 职责：预处理音视频数据。
        1. 初始化音视频播放组件（初始化 FFmpeg/SDL）。
        2. 对多媒体文件进行解封装，然后对视频流/音频流进行解码，视频交给 VideoWidget 进行渲染、音频交给 SDL 进行播放。
           （不同的封装格式，内部的数据流可能是一样的，而外部的壳却不一样（Header 和数据组织方式））
        3. 维护好自身的播放状态：播放、暂停、停止。
        4. 因为同时要进行解封装、视频解码、音频解码、视频渲染、音频播放，必须多线程。VideoPlayer 内部管理着三个线程，其中：
                A 线程负责解封装，然后按照媒体类型分别放入视频队列和音频队列。
                B 线程负责对视频流进行解码、像素转换然后渲染。
                C 线程（SDL 线程）负责对音频流进行解码、重采样和播放（SDL 不支持 fltp 格式的 pcm，于是要进行重采样。）。
        5. 因为使用了多线程，VideoPlayer 内部使用了互斥锁来保证队列中的数据安全。
        6. 在播放完成后，要对相关自由进行使用。

四、消费者模型与线程同步互斥

      1. 生产者：解封装产生 AVPacakget
      2. 消费者：对 AvPackget 进行解码得到 AVFrame
      3. 这里互斥锁使用的是 SDL 中的锁，不过原理都是差不多的。

五、音视频同步

      方式1：视频同步到音频（以音频为标准）
      方式2：音频同步到视频（以视频为标准，但是这里使用 SDL 播放音频，已经确定了 SDL 的解码速度，所以无法干啥音频的播放，所以不适用。）

    pts 用于音视频同步：
        pts 表示对应的包应该在什么时候展示。
        单位是 AVStream 中的 time_base

六、FFmpeg时间 与 现实时间的转换

    现实时间
        比如一个视频的时长是120秒，其中120秒就是现实时间
        比如一个视频播放到了第58秒，其中第58秒就是现实时间

    FFmpeg时间
        1> 时间戳（timestamp），类型是 int64_t(dts/pts)
        2> 时间基（time base\unit），是时间戳的单位，类型是AVRational

    FFmpeg时间 与 现实时间的转换
        现实时间 = 时间戳 * (时间基的分子 / 时间基的分母)
        现实时间 = 时间戳 * av_q2d(时间基)
        时间戳 = 现实时间 / (时间基的分子 / 时间基
========================================================================= */

#endif // README_H
